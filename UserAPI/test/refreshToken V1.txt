hash refresh token pke cryto , hash juga yg di cookienya sama dbnya

user-service.js
const login = async (req) => {
    const loginRequest = validate(loginUserValidation, req);

    const user = await prismaClient.user.findUnique({
        where: {
            email: loginRequest.email
        },
        select: {
            id: true,
            name: true,
            email: true,
            password: true,
        }
    })
    if (!user) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const isPasswordValid = await bcrypt.compare(loginRequest.password, user.password);
    if (!isPasswordValid) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const payload = {
        userId: user.id,
        name: user.name,
        email: user.email
    };

    // Menggunakan variabel lingkungan untuk waktu kedaluwarsa
    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY); // Default 20 menit
    const refreshTokenExpiry = parseInt(process.env.REF_TOKEN_EXPIRY); // Default 1 hari

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry
    });
    const refreshToken = jwt.sign(payload, process.env.REF_TOKEN_SECRET, {
        expiresIn: refreshTokenExpiry
    });

    // Hitung waktu kedaluwarsa untuk refresh token
    const expiresAt = new Date(Date.now() + refreshTokenExpiry * 1000);

    await prismaClient.refreshToken.create({
        data: {
            token: refreshToken,
            userId: user.id,
            expiresAt: expiresAt
        }
    });

    return {
        name: user.name,
        accessToken: accessToken,
        cookies: {
            refreshToken: {
                value: refreshToken,
                options: {
                    httpOnly: true,
                    maxAge: refreshTokenExpiry * 1000,
                    // secure: true, // aktifkan untuk https saja
                    // sameSite: "none"
                }
            }
        }

    };
}

//getUser
const get = async (email) => {
    email = validate(getUserValidation, email);
    const user = await prismaClient.user.findUnique({
        where: {
            email: email,
        },
        select: {
            id: true,
            email: true,
            name: true
        }
    })

    if (!user) {
        throw new ResponseError(404, "User not found")
    }

    return user
}


const refreshToken = async (req) => {
    const cookieRefreshToken = req.cookies?.refreshToken;

    if (!cookieRefreshToken) {
        throw new ResponseError(401, "No refresh token provided");
    }

    const decoded = jwt.verify(cookieRefreshToken, process.env.REF_TOKEN_SECRET);

    // Validasi payload tambahan
    if (!decoded.userId) {
        throw new ResponseError(401, "Invalid token payload");
    }

    // Cari token di database
    const refreshTokenEntry = await prismaClient.refreshToken.findUnique({
        where: {
            token: cookieRefreshToken,
            userId: decoded.userId
        },
        include: {
            user: {
                select: {
                    id: true,
                    name: true,
                    email: true
                }
            }
        }
    });

    // Validasi token di database
    if (!refreshTokenEntry) {
        throw new ResponseError(401, "Invalid refresh token");
    }

    // Periksa masa berlaku token
   if (new Date() > refreshTokenEntry.expiresAt) {
        // Hapus token yang expired
        await prismaClient.refreshToken.delete({
            where: {
                token: cookieRefreshToken
            }
        });
        throw new ResponseError(401, "Refresh token has expired");
    }

    // Generate ulang access token
    const payload = {
        userId: refreshTokenEntry.user.id,
        name: refreshTokenEntry.user.name,
        email: refreshTokenEntry.user.email
    };

    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY);

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry 
    });

    return {
        name: refreshTokenEntry.user.name,
        accessToken: accessToken
    };
} const login = async (req) => {
    const loginRequest = validate(loginUserValidation, req);

    const user = await prismaClient.user.findUnique({
        where: {
            email: loginRequest.email
        },
        select: {
            id: true,
            name: true,
            email: true,
            password: true,
        }
    })
    if (!user) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const isPasswordValid = await bcrypt.compare(loginRequest.password, user.password);
    if (!isPasswordValid) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const payload = {
        userId: user.id,
        name: user.name,
        email: user.email
    };

    // Menggunakan variabel lingkungan untuk waktu kedaluwarsa
    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY); // Default 20 menit
    const refreshTokenExpiry = parseInt(process.env.REF_TOKEN_EXPIRY); // Default 1 hari

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry
    });
    const refreshToken = jwt.sign(payload, process.env.REF_TOKEN_SECRET, {
        expiresIn: refreshTokenExpiry
    });

    // Hitung waktu kedaluwarsa untuk refresh token
    const expiresAt = new Date(Date.now() + refreshTokenExpiry * 1000);

    await prismaClient.refreshToken.create({
        data: {
            token: refreshToken,
            userId: user.id,
            expiresAt: expiresAt
        }
    });

    return {
        name: user.name,
        accessToken: accessToken,
        cookies: {
            refreshToken: {
                value: refreshToken,
                options: {
                    httpOnly: true,
                    maxAge: refreshTokenExpiry * 1000,
                    // secure: true, // aktifkan untuk https saja
                    // sameSite: "none"
                }
            }
        }

    };
}

//getUser
const get = async (email) => {
    email = validate(getUserValidation, email);
    const user = await prismaClient.user.findUnique({
        where: {
            email: email,
        },
        select: {
            id: true,
            email: true,
            name: true
        }
    })

    if (!user) {
        throw new ResponseError(404, "User not found")
    }

    return user
}


const refreshToken = async (req) => {
    const cookieRefreshToken = req.cookies?.refreshToken;

    if (!cookieRefreshToken) {
        throw new ResponseError(401, "No refresh token provided");
    }

    const decoded = jwt.verify(cookieRefreshToken, process.env.REF_TOKEN_SECRET);

    // Validasi payload tambahan
    if (!decoded.userId) {
        throw new ResponseError(401, "Invalid token payload");
    }

    // Cari token di database
    const refreshTokenEntry = await prismaClient.refreshToken.findUnique({
        where: {
            token: cookieRefreshToken,
            userId: decoded.userId
        },
        include: {
            user: {
                select: {
                    id: true,
                    name: true,
                    email: true
                }
            }
        }
    });

    // Validasi token di database
    if (!refreshTokenEntry) {
        throw new ResponseError(401, "Invalid refresh token");
    }

    // Periksa masa berlaku token
   if (new Date() > refreshTokenEntry.expiresAt) {
        // Hapus token yang expired
        await prismaClient.refreshToken.delete({
            where: {
                token: cookieRefreshToken
            }
        });
        throw new ResponseError(401, "Refresh token has expired");
    }

    // Generate ulang access token
    const payload = {
        userId: refreshTokenEntry.user.id,
        name: refreshTokenEntry.user.name,
        email: refreshTokenEntry.user.email
    };

    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY);

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry 
    });

    return {
        name: refreshTokenEntry.user.name,
        accessToken: accessToken
    };
} const login = async (req) => {
    const loginRequest = validate(loginUserValidation, req);

    const user = await prismaClient.user.findUnique({
        where: {
            email: loginRequest.email
        },
        select: {
            id: true,
            name: true,
            email: true,
            password: true,
        }
    })
    if (!user) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const isPasswordValid = await bcrypt.compare(loginRequest.password, user.password);
    if (!isPasswordValid) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const payload = {
        userId: user.id,
        name: user.name,
        email: user.email
    };

    // Menggunakan variabel lingkungan untuk waktu kedaluwarsa
    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY); // Default 20 menit
    const refreshTokenExpiry = parseInt(process.env.REF_TOKEN_EXPIRY); // Default 1 hari

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry
    });
    const refreshToken = jwt.sign(payload, process.env.REF_TOKEN_SECRET, {
        expiresIn: refreshTokenExpiry
    });

    // Hitung waktu kedaluwarsa untuk refresh token
    const expiresAt = new Date(Date.now() + refreshTokenExpiry * 1000);

    await prismaClient.refreshToken.create({
        data: {
            token: refreshToken,
            userId: user.id,
            expiresAt: expiresAt
        }
    });

    return {
        name: user.name,
        accessToken: accessToken,
        cookies: {
            refreshToken: {
                value: refreshToken,
                options: {
                    httpOnly: true,
                    maxAge: refreshTokenExpiry * 1000,
                    // secure: true, // aktifkan untuk https saja
                    // sameSite: "none"
                }
            }
        }

    };
}

//getUser
const get = async (email) => {
    email = validate(getUserValidation, email);
    const user = await prismaClient.user.findUnique({
        where: {
            email: email,
        },
        select: {
            id: true,
            email: true,
            name: true
        }
    })

    if (!user) {
        throw new ResponseError(404, "User not found")
    }

    return user
}


const refreshToken = async (req) => {
    const cookieRefreshToken = req.cookies?.refreshToken;

    if (!cookieRefreshToken) {
        throw new ResponseError(401, "No refresh token provided");
    }

    const decoded = jwt.verify(cookieRefreshToken, process.env.REF_TOKEN_SECRET);

    // Validasi payload tambahan
    if (!decoded.userId) {
        throw new ResponseError(401, "Invalid token payload");
    }

    // Cari token di database
    const refreshTokenEntry = await prismaClient.refreshToken.findUnique({
        where: {
            token: cookieRefreshToken,
            userId: decoded.userId
        },
        include: {
            user: {
                select: {
                    id: true,
                    name: true,
                    email: true
                }
            }
        }
    });

    // Validasi token di database
    if (!refreshTokenEntry) {
        throw new ResponseError(401, "Invalid refresh token");
    }

    // Periksa masa berlaku token
   if (new Date() > refreshTokenEntry.expiresAt) {
        // Hapus token yang expired
        await prismaClient.refreshToken.delete({
            where: {
                token: cookieRefreshToken
            }
        });
        throw new ResponseError(401, "Refresh token has expired");
    }

    // Generate ulang access token
    const payload = {
        userId: refreshTokenEntry.user.id,
        name: refreshTokenEntry.user.name,
        email: refreshTokenEntry.user.email
    };

    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY);

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry 
    });

    return {
        name: refreshTokenEntry.user.name,
        accessToken: accessToken
    };
} const login = async (req) => {
    const loginRequest = validate(loginUserValidation, req);

    const user = await prismaClient.user.findUnique({
        where: {
            email: loginRequest.email
        },
        select: {
            id: true,
            name: true,
            email: true,
            password: true,
        }
    })
    if (!user) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const isPasswordValid = await bcrypt.compare(loginRequest.password, user.password);
    if (!isPasswordValid) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const payload = {
        userId: user.id,
        name: user.name,
        email: user.email
    };

    // Menggunakan variabel lingkungan untuk waktu kedaluwarsa
    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY); // Default 20 menit
    const refreshTokenExpiry = parseInt(process.env.REF_TOKEN_EXPIRY); // Default 1 hari

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry
    });
    const refreshToken = jwt.sign(payload, process.env.REF_TOKEN_SECRET, {
        expiresIn: refreshTokenExpiry
    });

    // Hitung waktu kedaluwarsa untuk refresh token
    const expiresAt = new Date(Date.now() + refreshTokenExpiry * 1000);

    await prismaClient.refreshToken.create({
        data: {
            token: refreshToken,
            userId: user.id,
            expiresAt: expiresAt
        }
    });

    return {
        name: user.name,
        accessToken: accessToken,
        cookies: {
            refreshToken: {
                value: refreshToken,
                options: {
                    httpOnly: true,
                    maxAge: refreshTokenExpiry * 1000,
                    // secure: true, // aktifkan untuk https saja
                    // sameSite: "none"
                }
            }
        }

    };
}

//getUser
const get = async (email) => {
    email = validate(getUserValidation, email);
    const user = await prismaClient.user.findUnique({
        where: {
            email: email,
        },
        select: {
            id: true,
            email: true,
            name: true
        }
    })

    if (!user) {
        throw new ResponseError(404, "User not found")
    }

    return user
}


const refreshToken = async (req) => {
    const cookieRefreshToken = req.cookies?.refreshToken;

    if (!cookieRefreshToken) {
        throw new ResponseError(401, "No refresh token provided");
    }

    const decoded = jwt.verify(cookieRefreshToken, process.env.REF_TOKEN_SECRET);

    // Validasi payload tambahan
    if (!decoded.userId) {
        throw new ResponseError(401, "Invalid token payload");
    }

    // Cari token di database
    const refreshTokenEntry = await prismaClient.refreshToken.findUnique({
        where: {
            token: cookieRefreshToken,
            userId: decoded.userId
        },
        include: {
            user: {
                select: {
                    id: true,
                    name: true,
                    email: true
                }
            }
        }
    });

    // Validasi token di database
    if (!refreshTokenEntry) {
        throw new ResponseError(401, "Invalid refresh token");
    }

    // Periksa masa berlaku token
   if (new Date() > refreshTokenEntry.expiresAt) {
        // Hapus token yang expired
        await prismaClient.refreshToken.delete({
            where: {
                token: cookieRefreshToken
            }
        });
        throw new ResponseError(401, "Refresh token has expired");
    }

    // Generate ulang access token
    const payload = {
        userId: refreshTokenEntry.user.id,
        name: refreshTokenEntry.user.name,
        email: refreshTokenEntry.user.email
    };

    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY);

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry 
    });

    return {
        name: refreshTokenEntry.user.name,
        accessToken: accessToken
    };
} const login = async (req) => {
    const loginRequest = validate(loginUserValidation, req);

    const user = await prismaClient.user.findUnique({
        where: {
            email: loginRequest.email
        },
        select: {
            id: true,
            name: true,
            email: true,
            password: true,
        }
    })
    if (!user) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const isPasswordValid = await bcrypt.compare(loginRequest.password, user.password);
    if (!isPasswordValid) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const payload = {
        userId: user.id,
        name: user.name,
        email: user.email
    };

    // Menggunakan variabel lingkungan untuk waktu kedaluwarsa
    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY); // Default 20 menit
    const refreshTokenExpiry = parseInt(process.env.REF_TOKEN_EXPIRY); // Default 1 hari

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry
    });
    const refreshToken = jwt.sign(payload, process.env.REF_TOKEN_SECRET, {
        expiresIn: refreshTokenExpiry
    });

    // Hitung waktu kedaluwarsa untuk refresh token
    const expiresAt = new Date(Date.now() + refreshTokenExpiry * 1000);

    await prismaClient.refreshToken.create({
        data: {
            token: refreshToken,
            userId: user.id,
            expiresAt: expiresAt
        }
    });

    return {
        name: user.name,
        accessToken: accessToken,
        cookies: {
            refreshToken: {
                value: refreshToken,
                options: {
                    httpOnly: true,
                    maxAge: refreshTokenExpiry * 1000,
                    // secure: true, // aktifkan untuk https saja
                    // sameSite: "none"
                }
            }
        }

    };
}

//getUser
const get = async (email) => {
    email = validate(getUserValidation, email);
    const user = await prismaClient.user.findUnique({
        where: {
            email: email,
        },
        select: {
            id: true,
            email: true,
            name: true
        }
    })

    if (!user) {
        throw new ResponseError(404, "User not found")
    }

    return user
}


const refreshToken = async (req) => {
    const cookieRefreshToken = req.cookies?.refreshToken;

    if (!cookieRefreshToken) {
        throw new ResponseError(401, "No refresh token provided");
    }

    const decoded = jwt.verify(cookieRefreshToken, process.env.REF_TOKEN_SECRET);

    // Validasi payload tambahan
    if (!decoded.userId) {
        throw new ResponseError(401, "Invalid token payload");
    }

    // Cari token di database
    const refreshTokenEntry = await prismaClient.refreshToken.findUnique({
        where: {
            token: cookieRefreshToken,
            userId: decoded.userId
        },
        include: {
            user: {
                select: {
                    id: true,
                    name: true,
                    email: true
                }
            }
        }
    });

    // Validasi token di database
    if (!refreshTokenEntry) {
        throw new ResponseError(401, "Invalid refresh token");
    }

    // Periksa masa berlaku token
   if (new Date() > refreshTokenEntry.expiresAt) {
        // Hapus token yang expired
        await prismaClient.refreshToken.delete({
            where: {
                token: cookieRefreshToken
            }
        });
        throw new ResponseError(401, "Refresh token has expired");
    }

    // Generate ulang access token
    const payload = {
        userId: refreshTokenEntry.user.id,
        name: refreshTokenEntry.user.name,
        email: refreshTokenEntry.user.email
    };

    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY);

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry 
    });

    return {
        name: refreshTokenEntry.user.name,
        accessToken: accessToken
    };
} const login = async (req) => {
    const loginRequest = validate(loginUserValidation, req);

    const user = await prismaClient.user.findUnique({
        where: {
            email: loginRequest.email
        },
        select: {
            id: true,
            name: true,
            email: true,
            password: true,
        }
    })
    if (!user) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const isPasswordValid = await bcrypt.compare(loginRequest.password, user.password);
    if (!isPasswordValid) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const payload = {
        userId: user.id,
        name: user.name,
        email: user.email
    };

    // Menggunakan variabel lingkungan untuk waktu kedaluwarsa
    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY); // Default 20 menit
    const refreshTokenExpiry = parseInt(process.env.REF_TOKEN_EXPIRY); // Default 1 hari

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry
    });
    const refreshToken = jwt.sign(payload, process.env.REF_TOKEN_SECRET, {
        expiresIn: refreshTokenExpiry
    });

    // Hitung waktu kedaluwarsa untuk refresh token
    const expiresAt = new Date(Date.now() + refreshTokenExpiry * 1000);

    await prismaClient.refreshToken.create({
        data: {
            token: refreshToken,
            userId: user.id,
            expiresAt: expiresAt
        }
    });

    return {
        name: user.name,
        accessToken: accessToken,
        cookies: {
            refreshToken: {
                value: refreshToken,
                options: {
                    httpOnly: true,
                    maxAge: refreshTokenExpiry * 1000,
                    // secure: true, // aktifkan untuk https saja
                    // sameSite: "none"
                }
            }
        }

    };
}

//getUser
const get = async (email) => {
    email = validate(getUserValidation, email);
    const user = await prismaClient.user.findUnique({
        where: {
            email: email,
        },
        select: {
            id: true,
            email: true,
            name: true
        }
    })

    if (!user) {
        throw new ResponseError(404, "User not found")
    }

    return user
}


const refreshToken = async (req) => {
    const cookieRefreshToken = req.cookies?.refreshToken;

    if (!cookieRefreshToken) {
        throw new ResponseError(401, "No refresh token provided");
    }

    const decoded = jwt.verify(cookieRefreshToken, process.env.REF_TOKEN_SECRET);

    // Validasi payload tambahan
    if (!decoded.userId) {
        throw new ResponseError(401, "Invalid token payload");
    }

    // Cari token di database
    const refreshTokenEntry = await prismaClient.refreshToken.findUnique({
        where: {
            token: cookieRefreshToken,
            userId: decoded.userId
        },
        include: {
            user: {
                select: {
                    id: true,
                    name: true,
                    email: true
                }
            }
        }
    });

    // Validasi token di database
    if (!refreshTokenEntry) {
        throw new ResponseError(401, "Invalid refresh token");
    }

    // Periksa masa berlaku token
   if (new Date() > refreshTokenEntry.expiresAt) {
        // Hapus token yang expired
        await prismaClient.refreshToken.delete({
            where: {
                token: cookieRefreshToken
            }
        });
        throw new ResponseError(401, "Refresh token has expired");
    }

    // Generate ulang access token
    const payload = {
        userId: refreshTokenEntry.user.id,
        name: refreshTokenEntry.user.name,
        email: refreshTokenEntry.user.email
    };

    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY);

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry 
    });

    return {
        name: refreshTokenEntry.user.name,
        accessToken: accessToken
    };
} const login = async (req) => {
    const loginRequest = validate(loginUserValidation, req);

    const user = await prismaClient.user.findUnique({
        where: {
            email: loginRequest.email
        },
        select: {
            id: true,
            name: true,
            email: true,
            password: true,
        }
    })
    if (!user) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const isPasswordValid = await bcrypt.compare(loginRequest.password, user.password);
    if (!isPasswordValid) {
        throw new ResponseError(401, "email or password is wrong")
    }

    const payload = {
        userId: user.id,
        name: user.name,
        email: user.email
    };

    // Menggunakan variabel lingkungan untuk waktu kedaluwarsa
    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY); // Default 20 menit
    const refreshTokenExpiry = parseInt(process.env.REF_TOKEN_EXPIRY); // Default 1 hari

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry
    });
    const refreshToken = jwt.sign(payload, process.env.REF_TOKEN_SECRET, {
        expiresIn: refreshTokenExpiry
    });

    // Hitung waktu kedaluwarsa untuk refresh token
    const expiresAt = new Date(Date.now() + refreshTokenExpiry * 1000);

    await prismaClient.refreshToken.create({
        data: {
            token: refreshToken,
            userId: user.id,
            expiresAt: expiresAt
        }
    });

    return {
        name: user.name,
        accessToken: accessToken,
        cookies: {
            refreshToken: {
                value: refreshToken,
                options: {
                    httpOnly: true,
                    maxAge: refreshTokenExpiry * 1000,
                    // secure: true, // aktifkan untuk https saja
                    // sameSite: "none"
                }
            }
        }

    };
}

//getUser
const get = async (email) => {
    email = validate(getUserValidation, email);
    const user = await prismaClient.user.findUnique({
        where: {
            email: email,
        },
        select: {
            id: true,
            email: true,
            name: true
        }
    })

    if (!user) {
        throw new ResponseError(404, "User not found")
    }

    return user
}


const refreshToken = async (req) => {
    const cookieRefreshToken = req.cookies?.refreshToken;

    if (!cookieRefreshToken) {
        throw new ResponseError(401, "No refresh token provided");
    }

    const decoded = jwt.verify(cookieRefreshToken, process.env.REF_TOKEN_SECRET);

    // Validasi payload tambahan
    if (!decoded.userId) {
        throw new ResponseError(401, "Invalid token payload");
    }

    // Cari token di database
    const refreshTokenEntry = await prismaClient.refreshToken.findUnique({
        where: {
            token: cookieRefreshToken,
            userId: decoded.userId
        },
        include: {
            user: {
                select: {
                    id: true,
                    name: true,
                    email: true
                }
            }
        }
    });

    // Validasi token di database
    if (!refreshTokenEntry) {
        throw new ResponseError(401, "Invalid refresh token");
    }

    // Periksa masa berlaku token
   if (new Date() > refreshTokenEntry.expiresAt) {
        // Hapus token yang expired
        await prismaClient.refreshToken.delete({
            where: {
                token: cookieRefreshToken
            }
        });
        throw new ResponseError(401, "Refresh token has expired");
    }

    // Generate ulang access token
    const payload = {
        userId: refreshTokenEntry.user.id,
        name: refreshTokenEntry.user.name,
        email: refreshTokenEntry.user.email
    };

    const accessTokenExpiry = parseInt(process.env.ACCESS_TOKEN_EXPIRY);

    const accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {
        expiresIn: accessTokenExpiry 
    });

    return {
        name: refreshTokenEntry.user.name,
        accessToken: accessToken
    };
} 

---------------------------------
user-controller.js
const login = async (req, res, next) => {
    try {
        const result = await userService.login(req.body);

        if (result.cookies && result.cookies.refreshToken) {
            res.cookie(
                'refreshToken',
                result.cookies.refreshToken.value,
                result.cookies.refreshToken.options
            );
        }

        res.status(200).json({
            name: result.name,
            accessToken: result.accessToken
        })
    } catch (e) {
        next(e);
    }
}

const get = async (req, res, next) => {
    try {
        const email = req.user.email;
        const result = await userService.get(email);
        res.status(200).json({
            data: result
        });
    } catch (e) {
        next(e);
    }
}

const refreshToken = async (req, res, next) => {
    try {
        const result = await userService.refreshToken(req);
        res.status(200).json({
            name: result.name,
            accessToken: result.accessToken
        });
    } catch (e) {
        next(e);
    }
}